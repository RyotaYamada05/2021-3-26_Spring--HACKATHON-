//=============================================================================
//
// スコア処理 [score.cpp]
// Author : 山田陵太
//
//=============================================================================

//=============================================================================
// インクルードファイル
//=============================================================================
#include "score.h"
#include "number.h"
#include "scene2d.h"

//=============================================================================
//静的メンバ変数宣言
//=============================================================================
int CScore::m_nScore = 0;

//=============================================================================
//スコアクラスのコンストラクタ
//=============================================================================
CScore::CScore(int nPriority) :CScene(nPriority)
{
	//各メンバ変数のクリア
	memset(m_apNumber, 0, sizeof(m_apNumber));
	m_nAddScore = 0;
	m_pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
}

//=============================================================================
//スコアクラスのデストラクタ
//=============================================================================
CScore::~CScore()
{
}

//=============================================================================
//スコアクラスのクリエイト処理
//=============================================================================
CScore * CScore::Create(D3DXVECTOR3 pos)
{
	//スコアクラスのポインタ変数
	CScore *pScore = NULL;

	//メモリの確保
	pScore = new CScore;

	//メモリが確保できていたら
	if (pScore)
	{
		pScore->m_pos = pos;
		//初期化処理呼び出し
		pScore->Init();
	}
	//メモリ確保に失敗した時
	else
	{
		return NULL;
	}

	return pScore;
}

//=============================================================================
//スコアクラスの初期化処理
//=============================================================================
HRESULT CScore::Init(void)
{
	//ナンバークラスをSCORE_MAX_NUM分生成
	m_apNumber[0] = CNumber::Create(0, CNumber::NUMBER_TYPE_002,	//表示する数字と種類
		D3DXVECTOR3((m_pos.x - SCORE_SIZE.x) + (SCORE_SIZE.x / 2),		//x軸の位置
			m_pos.y + (SCORE_SIZE.y / 2), //yの位置
			0.0f),	//zの位置
		SCORE_SIZE, COLOR_WHITE);	//サイズと色

	return S_OK;

}

//=============================================================================
//スコアクラスの終了処理
//=============================================================================
void CScore::Uninit(void)
{
	for (int nCount = 0; nCount < SCORE_MAX_NUM; nCount++)
	{
		if (m_apNumber[nCount])
		{
			//ナンバークラスの終了処理呼び出し
			m_apNumber[nCount]->Uninit();

			//メモリの削除
			delete m_apNumber[nCount];

			//メモリのクリア
			m_apNumber[nCount] = NULL;
		}
	}

	//オブジェクトの破棄
	SetDeathFlag();
}

//=============================================================================
//スコアクラスの更新処理
//=============================================================================
void CScore::Update(void)
{
	// 1フレーム前の敵の倒した数が現在の倒した数より少なかったら
	if (m_nAddScore < m_nScore)
	{
		// 加算して大きくする
		m_nAddScore += 1;
	}

	float fIndex = 0.0f;  //指数　(スコア表示用)
	float fRadix = 10.0f; //基数　(スコア表示用)

	// 数字の設定
	for (fIndex = 0; fIndex < SCORE_MAX_NUM; fIndex++)
	{
		int nScore = (int)powf(fRadix, fIndex);
		int nScore2 = (int)powf(fRadix, fIndex + 1);
		int nAnswer = (m_nAddScore % nScore2) / nScore;

		if (!m_apNumber[(int)fIndex] && nAnswer > 0)
		{
			m_apNumber[(int)fIndex] = CNumber::Create(0, CNumber::NUMBER_TYPE_002,	//表示する数字と種類
				D3DXVECTOR3((m_pos.x) - ((fIndex * SCORE_SIZE.x) + (SCORE_SIZE.x / 2)),		//x軸の位置
					m_pos.y + (SCORE_SIZE.y / 2), //yの位置
					0.0f),	//zの位置
				SCORE_SIZE, COLOR_WHITE);	//サイズと色
		}

		if (m_apNumber[(int)fIndex])
		{
			// 各ナンバーのセット
			m_apNumber[(int)fIndex]->SetNumber(nAnswer);
		}
	}
}

//=============================================================================
//スコアクラスの描画処理
//=============================================================================
void CScore::Draw(void)
{
	for (int nCount = 0; nCount < SCORE_MAX_NUM; nCount++)
	{
		if (m_apNumber[nCount])
		{
			//ナンバークラスの描画処理呼び出し
			m_apNumber[nCount]->Draw();
		}
	}
}

//=============================================================================
//スコアクラスのスコア加算処理
//=============================================================================
void CScore::AddScore(const int nScore)
{
	//スコアの加算
	m_nScore += nScore;
}

//=============================================================================
//スコアクラスのスコア取得処理
//=============================================================================
int CScore::GetScore(void)
{
	return m_nScore;
}
